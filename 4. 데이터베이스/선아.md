# 선아

### 4.1 데이터베이스

- 데이터베이스: 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되어 있는 데이터의 모음
- DBMS: 데이터베이스를 제어, 관리하는 통합 시스템
- Entity: 데이터로 관리할 대상
    - 약한 엔티티: 독립적으로 존재할 수 없는 엔티티. 강한 엔티티의 존재 여부에 따라 종속적임
    - 강한 엔티티: 독립적으로 존재할 수 있는 엔티티
- Relation: 데이터베이스에서 정보를 구분하여 저장하는 기본 단위
    - 관계형 데이터베이스에서는 Relation = Table
    - NoSQL 데이터베이스에서는 Relation = Collection
- Attribute(속성): 엔티티가 가질 수 있는 고유 정보 항목
- 도메인(=타입): 속성이 가질 수 있는 값의 범위
- 필드 타입
    - 숫자 타입
        - TINYINT(1 byte)
        - SMALLINT(2 byte)
        - MEDIUMINT(3 byte)
        - INT(4 byte)
        - BIGINT(8 byte)
    - 날짜 타입
        - DATE(날짜)
        - DATETIME(날짜+시간, 8 byte)
        - TIMESTAMP(1970-01-01부터 흐른 초 단위 수, 4 byte)
    - 문자 타입:
        - CHAR(고정 길이 문자열. 짧은 길이라도 max 길이로 저장)
        - VARCHAR(가변 길이 문자열. 실제 문자 길이 + 1 byte로 저장)
        - TEXT(긴 길이의 문자열)
        - BLOB(큰 데이터 저장 시 사용)
        - ENUM(여러 개 중 한 개만 선택 가능. 잘못된 값 선택 시 빈 문자열)
        - SET(다중 선택 가능)
- 관계
    
    ![image](https://github.com/user-attachments/assets/f9b1f230-0b4a-4266-b80f-0ad4170274f3)
    
    - 1:1 관계
    - 1:N 관계
    - 1:M 관계
- 키
    - 키의 특징
        - 유일성: 튜플을 유일하게 식별할 수 있어야 한다는 성질
        - 최소성: 최소한의 속성 개수를 사용하여 유일성을 보장해야한다는 성질
    - 키 종류
        - 기본키 PK: 유일성과 최소성 만족
            - 주로 인조키(UUID)를 기본키로 설정
        - 외래키 FK: 다른 테이블의 PK를 참조하여 사용하는 값
            - 외래키는 중복되어도 됨
        - 후보키: 기본키가 될 수 있는 후보들. 유일성과 최소성 만족
        - 대체키: 후보키가 여러 개인 경우, 기본키로 설정되지 않은 다른 키들
        - 슈퍼키: 유일성은 만족하지만, 최소성을 만족하지 않는 키

### 4.2 ERD와 정규화 과정

정규화

- 정규화가 필요한 이유
    1. 데이터 중복 제거
    2. 삽입/이상/삭제 이상 방지
    3. 데이터 무결성 방지: 데이터 일관성 유지

1. 제 1 정규화
    - 릴레이션의 모든 도메인은 원자 값으로 구성되어야 한다
2. 제 2 정규화
    - 부분 함수 종속성 제거
    - 부분 함수 종속성 : PK 중 일부에만 의존한 속성이 있는 경우, 테이블을 분리해야 함
3. 제 3 정규화
    - 이행적 함수 종속성 제거
    - 이행적 함수 종속성 : A → B, B → C 일 때 A → C라면, A&B / B&C로 테이블 분리 필요
4. BCNF
    - 모든 결정자(다른 속성을 결정짓는 키)가 후보키가 되도록 테이블을 분해하는 것

### 4.3 트랜잭션

- 트랜잭션의 4대 원칙
    1. Atomicity 원자성: 트랜잭션은 작업의 모든 단계가 완전히 수행되었거나, 전혀 수행되지 않아야 함
        - commit: 쿼리가 성공적으로 처리되었음을 확정하는 명령어
        - rollback: 해당 트랜잭션 실행 전으로 되돌리는 명령어
    2. Consistency 일관성: 데이터베이스 일관성을 유지해야 함
        - 정의된 규칙과 제약 조건을 준수해야 함
        - 트랜잭션 전후의 데이터 상태가 일관되어야 함
    3. Isolation 격리성: 각 트랜잭션은 독립적으로 실행되어야 하며, 다른 트랜잭션의 영향을 받지 않아야 함
        
        ![image](https://github.com/user-attachments/assets/a8304e23-9883-4227-a8cc-48202f328c34)
        
        - 격리 수준
            - SERIALIZABLE: 트랜잭션 결과의 직렬 실행을 보장
                - 락 범위가 넓고, 조회 쿼리도 락을 걸기 떄문에 데드락이 발생할 가능성이 가장 높음
            - REPEATABLE_READ: 하나의 트랜잭션이 write한 행을 다른 트랜잭션이 수행할 수 없음. 그러나 새로운 행을 추가할 수 있음
            - READ_COMMITTED: 커밋 완료된 데이터에 대해서만 조회 허용. 그러나 값은 수정할 수 있기 때문에, 같은 행을 다시 읽었을 때 값이 바뀔 수 있음
            - READ_UNCOMMITTED: 커밋되기 이전 데이터도 읽을 수 있음
                - 데이터 일관성보다 성능이 중요할 떄 사용
        - 격리 수준에 따라 발생하는 현상
            - Phantom Read: 한 트랜잭션이 같은 조건의 범위 조회를 두 번 했는데, 그 사이에 다른 트랜잭션이 새로운 행을 삽입하거나 삭제해서 결과가 달라지는 경우
            - Non-Repeatable Read: 한 트랜잭션이 같은 데이터를 두 번 읽는데, 그 사이에 다른 트랜잭션이 값을 수정해서 두 번째 조회에서 값이 바뀌는 경우
            - Dirty Read: 수정 중인 행의 데이터를 다른 트랜잭션에서 읽은 경우
    4. Durability 지속성: 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함
- 무결성
    1. 개체 무결성: PK는 반드시 NOT NULL이고 유일해야 한다.
    2. 참조 무결성: FK는 반드시 참조하는 PK와 일치하거나 NULL이어야 한다.
    3. 고유 무결성: UNIQUE 키워드 설정 시 그 속성값은 모두 고유해야 한다.
    4. NULL 무결성: NOT NULL 조건을 설정한 경우, 그 속성값은 NULL이 될 수 없다.

### 4.4 데이터베이스의 종류

1. MySQL
    - C, C++로 구성, MyISAM 인덱스 압축 기술, B 트리 기반 인덱스, 스레드 기반의 메모리 할당 시스템, 최대 64개의 인덱스 제공
    - 모듈식 아키텍처를 가지고 있어  스토리지 엔진을 쉽게 변경할 수 있음
    - 장점: 데이터 웨어하우징, 트랜잭션 처리, 고가용성 처리
    - 쿼리 캐싱 기능 제공 → 동일한 쿼리를 요청시 구문 분석, 최적화 및 실행을 건너뛰고 캐시의 출력만 표시

2. PostgreSQL
    - VACUUM: 디스크 조각이 차지하는 영역을 회수할 수 있는 장치
    - 최대 테이블 크기: 32TB
    - SQL, JSON을 활용하여 데이터에 접근 가능
    - 배치 작업 가능

3. NoSQL 데이터베이스
    - SQL을 사용하지 않는 데이터베이스
        
        3-1. MongoDB
        
        - ObjectID
            - 도큐먼트를 생성할 때마다 다른 컬렉션에서 중복된 값을 지니기 힘든 유니크한 값
            - 기본키로 지정
            - timestamp(4 byte) - random byte (5 byte) - counter (3 byte)
        - JSON을 통해 데이터에 접근할 수 있음
        - Binary JSON 형태로 데이터 저장
        - 키-값 데이터 모델에서 확장된 도큐먼트 기반 데이터베이스
        - 장점
            - 확장성이 뛰어남
            - 빅데이터를 저장할 때 성능이 좋음
            - 스키마를 정해 놓지 않아서 다양한 도메인의 데이터베이스를 기반으로 분석하거나 로깅할 수 있음
        
        3-2. redis
        
        - 인메모리 데이터베이스
        - 키-값 데이터모델 기반의 데이터베이스
        - 문자열, 셋, 해시 지원
        - push/sub 기능을 통해 채팅 시스템, 캐싱 계층, 세션 정보 관리, 실시간 순위표 서비스

### 4.5 인덱스

- 인덱스
    - 데이터를 빠르게 찾을 수 있는 하나의 장치
    - 효율적인 이유: 균형 잡힌 트리 구조와 트리 깊이의 대수 확장성 때문
    - 대수 확장성이란? 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미 → 인덱스가 한 깊이 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가

- B tree
    - 탐색: 루트 노드 → 브랜치 노드 → 리프 노드
    - 각 노드가 가질 수 있는 key 값의 개수는 정해져 있음
    - 노드 내부에서 Key값은 정렬되어 있으며, Key의 왼쪽 자식은 나보다 작고, Key의 오른쪽 자식은 나보다 크다

### 4.6 조인의 종류

![image](https://github.com/user-attachments/assets/9b2d6bb9-68a9-4257-aafc-07b73d589c39)

- inner join: 왼쪽 테이블과 오른쪽 테이블의 일치하는 두 행만 표기
- left outer join: 왼쪽 테이블의 모든 행이 결과 테이블에 표기
- right outer join: 오른쪽 테이블의 모든 행이 결과 테이블에 표기
- full outer join: 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기

### 4.7 조인의 원리

- 중첩 루프 조인(Nested Loop Join)
    - 중첩 For문처럼 조건에 맞는 조인 실행 → 랜덤 접근에 대한 비용이 높으므로 대용량 테이블에서는 사용 X
    - 테이블을 작은 블록으로 나누어 블록끼리 결합하는 블록 중첩 루프 조인(Block Nested Loop) 방식도 존재
- 정렬 병합 조인
    - 각 테이블에 조인할 필드 기준으로 정렬한 뒤, 조인 작업 수행
    - 사용 조건
        - 조인에 사용할 인덱스가 없을 때
        - 대용량 테이블 조인일 때
        - 조인 조건으로 범위 비교 연산자를 사용할 때
- 해시 조인
    - 해시테이블을 기반으로 조인
    - 동등 조인에서만 사용 가능
    - MySQL에서는 두 단계로 나누어서 처리함
        1. 빌드 단계: 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계
        2. 프로브 단계: 레코드 읽기 진행 & 비교하는 키값과 일치하는 레코드를 찾아 결과값으로 반환
