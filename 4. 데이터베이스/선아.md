# 선아

### 4.1 데이터베이스

- 데이터베이스: 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되어 있는 데이터의 모음
- DBMS: 데이터베이스를 제어, 관리하는 통합 시스템
- Entity: 데이터로 관리할 대상
    - 약한 엔티티: 독립적으로 존재할 수 없는 엔티티. 강한 엔티티의 존재 여부에 따라 종속적임
    - 강한 엔티티: 독립적으로 존재할 수 있는 엔티티
- Relation: 데이터베이스에서 정보를 구분하여 저장하는 기본 단위
    - 관계형 데이터베이스에서는 Relation = Table
    - NoSQL 데이터베이스에서는 Relation = Collection
- Attribute(속성): 엔티티가 가질 수 있는 고유 정보 항목
- 도메인(=타입): 속성이 가질 수 있는 값의 범위
- 필드 타입
    - 숫자 타입
        - TINYINT(1 byte)
        - SMALLINT(2 byte)
        - MEDIUMINT(3 byte)
        - INT(4 byte)
        - BIGINT(8 byte)
    - 날짜 타입
        - DATE(날짜)
        - DATETIME(날짜+시간, 8 byte)
        - TIMESTAMP(1970-01-01부터 흐른 초 단위 수, 4 byte)
    - 문자 타입:
        - CHAR(고정 길이 문자열. 짧은 길이라도 max 길이로 저장)
        - VARCHAR(가변 길이 문자열. 실제 문자 길이 + 1 byte로 저장)
        - TEXT(긴 길이의 문자열)
        - BLOB(큰 데이터 저장 시 사용)
        - ENUM(여러 개 중 한 개만 선택 가능. 잘못된 값 선택 시 빈 문자열)
        - SET(다중 선택 가능)
- 관계
    
    ![image](https://github.com/user-attachments/assets/f9b1f230-0b4a-4266-b80f-0ad4170274f3)
    
    - 1:1 관계
    - 1:N 관계
    - 1:M 관계
- 키
    - 키의 특징
        - 유일성: 튜플을 유일하게 식별할 수 있어야 한다는 성질
        - 최소성: 최소한의 속성 개수를 사용하여 유일성을 보장해야한다는 성질
    - 키 종류
        - 기본키 PK: 유일성과 최소성 만족
            - 주로 인조키(UUID)를 기본키로 설정
        - 외래키 FK: 다른 테이블의 PK를 참조하여 사용하는 값
            - 외래키는 중복되어도 됨
        - 후보키: 기본키가 될 수 있는 후보들. 유일성과 최소성 만족
        - 대체키: 후보키가 여러 개인 경우, 기본키로 설정되지 않은 다른 키들
        - 슈퍼키: 유일성은 만족하지만, 최소성을 만족하지 않는 키

### 4.2 ERD와 정규화 과정

정규화

- 정규화가 필요한 이유
    1. 데이터 중복 제거
    2. 삽입/이상/삭제 이상 방지
    3. 데이터 무결성 방지: 데이터 일관성 유지

1. 제 1 정규화
    - 릴레이션의 모든 도메인은 원자 값으로 구성되어야 한다
2. 제 2 정규화
    - 부분 함수 종속성 제거
    - 부분 함수 종속성 : PK 중 일부에만 의존한 속성이 있는 경우, 테이블을 분리해야 함
3. 제 3 정규화
    - 이행적 함수 종속성 제거
    - 이행적 함수 종속성 : A → B, B → C 일 때 A → C라면, A&B / B&C로 테이블 분리 필요
4. BCNF
    - 모든 결정자(다른 속성을 결정짓는 키)가 후보키가 되도록 테이블을 분해하는 것

### 4.3 트랜잭션

- 트랜잭션의 4대 원칙
    1. Atomicity 원자성: 트랜잭션은 작업의 모든 단계가 완전히 수행되었거나, 전혀 수행되지 않아야 함
        - commit: 쿼리가 성공적으로 처리되었음을 확정하는 명령어
        - rollback: 해당 트랜잭션 실행 전으로 되돌리는 명령어
    2. Consistency 일관성: 데이터베이스 일관성을 유지해야 함
        - 정의된 규칙과 제약 조건을 준수해야 함
        - 트랜잭션 전후의 데이터 상태가 일관되어야 함
    3. Isolation 격리성: 각 트랜잭션은 독립적으로 실행되어야 하며, 다른 트랜잭션의 영향을 받지 않아야 함
        
        ![image](https://github.com/user-attachments/assets/a8304e23-9883-4227-a8cc-48202f328c34)
        
        - 격리 수준
            - SERIALIZABLE: 트랜잭션 결과의 직렬 실행을 보장
                - 락 범위가 넓고, 조회 쿼리도 락을 걸기 떄문에 데드락이 발생할 가능성이 가장 높음
            - REPEATABLE_READ: 하나의 트랜잭션이 write한 행을 다른 트랜잭션이 수행할 수 없음. 그러나 새로운 행을 추가할 수 있음
            - READ_COMMITTED: 커밋 완료된 데이터에 대해서만 조회 허용. 그러나 값은 수정할 수 있기 때문에, 같은 행을 다시 읽었을 때 값이 바뀔 수 있음
            - READ_UNCOMMITTED: 커밋되기 이전 데이터도 읽을 수 있음
                - 데이터 일관성보다 성능이 중요할 떄 사용
        - 격리 수준에 따라 발생하는 현상
            - Phantom Read: 한 트랜잭션이 같은 조건의 범위 조회를 두 번 했는데, 그 사이에 다른 트랜잭션이 새로운 행을 삽입하거나 삭제해서 결과가 달라지는 경우
            - Non-Repeatable Read: 한 트랜잭션이 같은 데이터를 두 번 읽는데, 그 사이에 다른 트랜잭션이 값을 수정해서 두 번째 조회에서 값이 바뀌는 경우
            - Dirty Read: 수정 중인 행의 데이터를 다른 트랜잭션에서 읽은 경우
    4. Durability 지속성: 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함
- 무결성
    1. 개체 무결성: PK는 반드시 NOT NULL이고 유일해야 한다.
    2. 참조 무결성: FK는 반드시 참조하는 PK와 일치하거나 NULL이어야 한다.
    3. 고유 무결성: UNIQUE 키워드 설정 시 그 속성값은 모두 고유해야 한다.
    4. NULL 무결성: NOT NULL 조건을 설정한 경우, 그 속성값은 NULL이 될 수 없다.
