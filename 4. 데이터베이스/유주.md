# 유주

# 데이터 베이스

: 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음
DBMS : 이를 관리하는 통합 시스템

## 4.1 데이터 베이스의 기본

### 4.1.1 엔터티

: 사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사
약한 엔터티: 혼자서 존재하지 못함, 종속적
강한 엔터티: 그 반대

### 4.1.2 릴레이션

: 데이터베이스에서 정보를 구분하여 저장하는 기본 단위

- 엔터티에 관한 데이터가 하나씩 담김
  ex. 데이터베이스의 테이블, NoSQL의 컬렉션

#### 테이블과 컬렉션

데이터베이스의 종류

1. 관계형 데이터베이스: MySQL ( 레코드-> 테이블-> 데이터베이스)
2. NoSQL 데이터베이스: MongoDb (도큐먼트- 컬렉션- 데이터베이스)

### 4.1.3 속성

: 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보
ex. 차에서 차 넘버, 바퀴 수 색깔, 차종 등

### 4.1.4 도메인

: 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합
ex. 성별-> 남,여

### 4.1.5 필드와 레코드

레코드= 튜플
엔터티를 정의하고 이를 기반으로 테이블 만들기

1. 속성에 맞는 타입을 정의하기
2. 속성이름을 영어에 매핑해서 설명한 타입을 넣어주기

### 필드타입

필드는 타입을 가진다.
ex. 이름은 문자열, 전화번호는 숫자
숫자 타입 : TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT
날짜타입 : DATE(날짜만), DATETIME(날짜와 시간), TIMESTAMP(날짜와 시간)
문자 타입 : CHAR, VARCHAR, TEXT, BLOB, ENUM, SET

[ CHAR, VARCHAR ]

- 수를 입력해서 몇자까지 입력할지 정한다, 문자를 저장할 수 있다.
  CHAR : 고정길이 문자열, 길이 0-255 사이 값, 저장길이가 고정일 때, 상수
  VARCHAR: 가변 길이 문자열, 길이 0-65,535, 저장 길이를 모를떄, 변수

[ TEXT, BLOB ]

- 큰 데이터를 저장할 때 사용
  TEXT: 큰 문자열 저장, 게시판 본문 등, 조회 속도가 느리다
  BLOB: 이미지, 동영상 등 큰 데이터 저장, 서버에 파일을 올리고 경로 설정을 VARCHAR로

[ ENUM, SET ]

- 문자열을 열거한 타입
  ENUM : x-small, small, medium, large, x-large/ 단일 선택만 가능
  SET : 여러개의 데이터 선택 가능, 비트 단위 연산 가능, 최대 64개 요소

### 4.1.6 관계

여러 테이블의 관계가 정의되어있음, 관계화살표 사용

[ 1:1 관계 ]
ex. 유저당 유저 이메일 한개

[ 1:N 관계]
: 함 개체가 다른 많은 개체를 포함하는 관계
ex. 한 유저당 장바구니에 여러 상품

[N:M 관계 ]
ex. 학생과 강의
-1:M, 1:N 관계의 두 테이블로 나눠서 설정

### 4.1.7 키

: 테이블 간의 관계를 명확히, 테이블 자체의 인덱스 설정

#### 기본키

프라이머리키, PK

- 유일성과 최소성을 만족하는 키
- 고유한 값, 중복 안됨
- 자연키, 인조키 중에 골라 설정
  ** 자연키 : 중복된 값을 제외하며 중복되지 않는 것을 자연스레 뽑아다가 나오는 키, 언젠간 변하는 속성
  ** 인조키 : 인위적으로 유저아이디를 부여, 고유식별자 생성, MySQL에서는 auto increment 등, 인위적으로 생성한 키, 불변
  ** 외래키: foreign key, FK 다른 테이블의 기본키를 그대로 참조하는 값, 개체와의 관계를 식별, 중복가능
  ** 후보키 : 기본키가 될 수 있는 후보들, 유일성과 최소성을 동시 만족
  ** 대체키 : 후보키가 두개 이상일 경우 기본키로 지정하고 남은 하나
  ** 슈퍼키 : 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

## 4.2 ERD와 정규화 과정

: 데이터베이스를 구축할 떄 가장 기초적인 뼈대 역할, 릴레이션 간의 관계를 정의
서비스 구축시 가장 신경써야한다.

### 4.2.1 ERD 의 중요성

시스템의 요구사항을 기반으로 작성된다.
이 ERD를 기반으로 데이터베이스를 구축한다.

- 관계형 구조로 표현 가능한 장점, 비정형 데이터를 충분히 표현할 수 없다는 단점

### 4.2.2 예제로 배우는 ERD

### 4.2.3 정규화 과정

: 릴레이션 간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나서 이를 해결하거나, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정

\*\* 데이터베이스 이상 현상 : 회원이 한 개의 등급을 가져야하는데 세개의 등급을 갖거나 삭제할 때 필요한 데이터가 같이 삭제되고, 데이터를 삽입해야하는데 하나의 필드 값이 NULL 이 되면 안되어서 삽입하기 어려운 현상

\*\* 정규화 과정 : 정규형 원칙을 기반으로 정규형을 만들어가는 과정

- 정규화된 정도는 정규형으로 표현한다.

#### 정규형 원칙

: 같은 의미를 표현하는 릴레이션이지만 더 좋은 구조로 만들어야하는 것

[ 제1정규형]
: 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값 만으로 구성되어야한다.

[제2정규형]
: 릴레이션이 제1 정규형이며 부분함수의 종속성을 제거한 형태

[제3정규형]
: 제 2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태

[보이스/코드 정규형] = BCNF
제 3규형이고, 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태

반정규화(비정규화) :성능 목적으로 다시 테이블을 합치는것

## 4.3 트랜잭션과 무결성

### 4.3.1 트랜잭션

: 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위 -데이터베이스에 접근하는 방법인 여러개의 쿼리를 하나로 묶는 단위

### 특징들

1. 원자성
   all or nothing
   트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징

2. 일관성
   : 허용된 방식으로만 제이터를 변경해야 하는 것

3. 격리성
   : 트랜잭션 수행시 서로 끼어들지 못하는 것

- 병렬 트랜잭션은 서로 격리되어 순차적으로 작동하느 것처럼 작동되어야함

#### 격리 수준

1. SERIALIZABLE : 트랜잭션 순차적 진행
2. REPEATABLE_READ : 하나의 트랜잭션이 수정한 행은 다른 트랜잭션이 수정하지 못하지만 새로운 행은 추가 가능
3. READ_COMMITTED : 가장 많이 사용됨, 기본값, 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다.
4. READ_UNCOMMITTED: 가장 낮은 격리 수준, 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠르다

5. 지속성
   : 성공적으로 수행된 트랜잭션은 영원히 반영되어야함

- 데이터베이스에 시스템 장애가 발생해도 원 상태로 복구하는 회복기능 필요

### 4.3.2 무결성

: 데이터의 정확성, 일관성, 유효성을 유지하는 것

- 무결성이 유지되어야 데이터베이스에 저장된 값에 대한 신뢰가 생긴다.

[ 무결성 제약조건 종류 ]
도메인 무결성: 컬럼 값이 허용된 범위나 타입을 지켜야 함
개체 무결성: 기본키는 반드시 유일하고 NULL이 될 수 없음
참조 무결성: 외래키 값은 참조하는 기본키 값과 일치하거나 NULL이어야 함
사용자 정의 무결성: 비즈니스 규칙에 따른 추가 조건
