# 유주

# 데이터 베이스

: 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음
DBMS : 이를 관리하는 통합 시스템

## 4.1 데이터 베이스의 기본

### 4.1.1 엔터티

: 사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사
약한 엔터티: 혼자서 존재하지 못함, 종속적
강한 엔터티: 그 반대

### 4.1.2 릴레이션

: 데이터베이스에서 정보를 구분하여 저장하는 기본 단위

- 엔터티에 관한 데이터가 하나씩 담김
  ex. 데이터베이스의 테이블, NoSQL의 컬렉션

#### 테이블과 컬렉션

데이터베이스의 종류

1. 관계형 데이터베이스: MySQL ( 레코드-> 테이블-> 데이터베이스)
2. NoSQL 데이터베이스: MongoDb (도큐먼트- 컬렉션- 데이터베이스)

### 4.1.3 속성

: 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보
ex. 차에서 차 넘버, 바퀴 수 색깔, 차종 등

### 4.1.4 도메인

: 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합
ex. 성별-> 남,여

### 4.1.5 필드와 레코드

레코드= 튜플
엔터티를 정의하고 이를 기반으로 테이블 만들기

1. 속성에 맞는 타입을 정의하기
2. 속성이름을 영어에 매핑해서 설명한 타입을 넣어주기

### 필드타입

필드는 타입을 가진다.
ex. 이름은 문자열, 전화번호는 숫자
숫자 타입 : TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT
날짜타입 : DATE(날짜만), DATETIME(날짜와 시간), TIMESTAMP(날짜와 시간)
문자 타입 : CHAR, VARCHAR, TEXT, BLOB, ENUM, SET

[ CHAR, VARCHAR ]

- 수를 입력해서 몇자까지 입력할지 정한다, 문자를 저장할 수 있다.
  CHAR : 고정길이 문자열, 길이 0-255 사이 값, 저장길이가 고정일 때, 상수
  VARCHAR: 가변 길이 문자열, 길이 0-65,535, 저장 길이를 모를떄, 변수

[ TEXT, BLOB ]

- 큰 데이터를 저장할 때 사용
  TEXT: 큰 문자열 저장, 게시판 본문 등, 조회 속도가 느리다
  BLOB: 이미지, 동영상 등 큰 데이터 저장, 서버에 파일을 올리고 경로 설정을 VARCHAR로

[ ENUM, SET ]

- 문자열을 열거한 타입
  ENUM : x-small, small, medium, large, x-large/ 단일 선택만 가능
  SET : 여러개의 데이터 선택 가능, 비트 단위 연산 가능, 최대 64개 요소

### 4.1.6 관계

여러 테이블의 관계가 정의되어있음, 관계화살표 사용

[ 1:1 관계 ]
ex. 유저당 유저 이메일 한개

[ 1:N 관계]
: 함 개체가 다른 많은 개체를 포함하는 관계
ex. 한 유저당 장바구니에 여러 상품

[N:M 관계 ]
ex. 학생과 강의
-1:M, 1:N 관계의 두 테이블로 나눠서 설정

### 4.1.7 키

: 테이블 간의 관계를 명확히, 테이블 자체의 인덱스 설정

#### 기본키

프라이머리키, PK

- 유일성과 최소성을 만족하는 키
- 고유한 값, 중복 안됨
- 자연키, 인조키 중에 골라 설정
  ** 자연키 : 중복된 값을 제외하며 중복되지 않는 것을 자연스레 뽑아다가 나오는 키, 언젠간 변하는 속성
  ** 인조키 : 인위적으로 유저아이디를 부여, 고유식별자 생성, MySQL에서는 auto increment 등, 인위적으로 생성한 키, 불변
  ** 외래키: foreign key, FK 다른 테이블의 기본키를 그대로 참조하는 값, 개체와의 관계를 식별, 중복가능
  ** 후보키 : 기본키가 될 수 있는 후보들, 유일성과 최소성을 동시 만족
  ** 대체키 : 후보키가 두개 이상일 경우 기본키로 지정하고 남은 하나
  ** 슈퍼키 : 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

## 4.2 ERD와 정규화 과정

: 데이터베이스를 구축할 떄 가장 기초적인 뼈대 역할, 릴레이션 간의 관계를 정의
서비스 구축시 가장 신경써야한다.

### 4.2.1 ERD 의 중요성

시스템의 요구사항을 기반으로 작성된다.
이 ERD를 기반으로 데이터베이스를 구축한다.

- 관계형 구조로 표현 가능한 장점, 비정형 데이터를 충분히 표현할 수 없다는 단점

### 4.2.2 예제로 배우는 ERD

### 4.2.3 정규화 과정

: 릴레이션 간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나서 이를 해결하거나, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정

\*\* 데이터베이스 이상 현상 : 회원이 한 개의 등급을 가져야하는데 세개의 등급을 갖거나 삭제할 때 필요한 데이터가 같이 삭제되고, 데이터를 삽입해야하는데 하나의 필드 값이 NULL 이 되면 안되어서 삽입하기 어려운 현상

\*\* 정규화 과정 : 정규형 원칙을 기반으로 정규형을 만들어가는 과정

- 정규화된 정도는 정규형으로 표현한다.

#### 정규형 원칙

: 같은 의미를 표현하는 릴레이션이지만 더 좋은 구조로 만들어야하는 것

[ 제1정규형]
: 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값 만으로 구성되어야한다.

[제2정규형]
: 릴레이션이 제1 정규형이며 부분함수의 종속성을 제거한 형태

[제3정규형]
: 제 2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태

[보이스/코드 정규형] = BCNF
제 3규형이고, 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태

반정규화(비정규화) :성능 목적으로 다시 테이블을 합치는것

## 4.3 트랜잭션과 무결성

### 4.3.1 트랜잭션

: 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위 -데이터베이스에 접근하는 방법인 여러개의 쿼리를 하나로 묶는 단위

### 특징들

1. 원자성
   all or nothing
   트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징

2. 일관성
   : 허용된 방식으로만 제이터를 변경해야 하는 것

3. 격리성
   : 트랜잭션 수행시 서로 끼어들지 못하는 것

- 병렬 트랜잭션은 서로 격리되어 순차적으로 작동하느 것처럼 작동되어야함

#### 격리 수준

1. SERIALIZABLE : 트랜잭션 순차적 진행
2. REPEATABLE_READ : 하나의 트랜잭션이 수정한 행은 다른 트랜잭션이 수정하지 못하지만 새로운 행은 추가 가능
3. READ_COMMITTED : 가장 많이 사용됨, 기본값, 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다.
4. READ_UNCOMMITTED: 가장 낮은 격리 수준, 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠르다

5. 지속성
   : 성공적으로 수행된 트랜잭션은 영원히 반영되어야함

- 데이터베이스에 시스템 장애가 발생해도 원 상태로 복구하는 회복기능 필요

### 4.3.2 무결성

: 데이터의 정확성, 일관성, 유효성을 유지하는 것

- 무결성이 유지되어야 데이터베이스에 저장된 값에 대한 신뢰가 생긴다.

[ 무결성 제약조건 종류 ]
도메인 무결성: 컬럼 값이 허용된 범위나 타입을 지켜야 함
개체 무결성: 기본키는 반드시 유일하고 NULL이 될 수 없음
참조 무결성: 외래키 값은 참조하는 기본키 값과 일치하거나 NULL이어야 함
사용자 정의 무결성: 비즈니스 규칙에 따른 추가 조건

## 4.4 데이터베이스의 종류

### 4.4.1 관계형 데이터베이스 (RDBMS)

: 행과 열을 가지는 표 형식을 저장하는 형태의 데이터베이스 , SQL로 조작

[ 데이터베이스 종류 ]

1. MySQL
   대부분의 운영체제와 호환되며 가장 많이 사용, C,C++ 기반, 최대 64개 인덱스 제공, B-트리 기반의 인덱스, 스레드 기반의 메모리 할당 시스템

- 모듈식 아키텍처로 쉽게 스토리지 엔진을 바꿀 수 있으며 데이터 웨어하우징, 트랜잭션 처리, 고가용성 처리에 강점

2. PostgreSQL
   그 다음으로 선호, 디스크 조각이 차지하는 영역을 회수할 수 있는 장치인 VACUUM 이 특징, 최대 테이블 32TB, JSON 으로 데이터 접근 가능

### 4.4.2 NoSQL 데이터베이스 (Not only SQL)

SQL을 사용하지 않는 데이터베이스 (ex. MongoDB, redis 등)

1. MongoDB
   JSON 으로 데이터 접근 가능, Binary JSON 형태로 데이터 저장, 와이어드 타이거 엔진이 기본 스토리지 엔진으로 장착된 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스

2. redis
   인메모리 데이터베이스이자 키-값 데이터모델 기반의 데이터베이스 , 문자열 데이터 타입이 기본이며 최대 512MB, 셋,헤시 등을 지원한다.

## 4.5 인덱스

333 4.5.1 인덱스의 필요성
인덱스 : 데이터를 빠르게 찾을 수 있는 하나의 장치 (책의 인덱스 같은것)

### 4.5.2 B-트리

인덱스는 보통 B-트리 라는 자료구조 , 시간복잡도는 log(N)
루트 노드, 리프 노드, 그 사이의 브랜치 노드 로 분류

- 찾는 항목이 있을 법한 리프노드로 들어가서 빠르게 탐색한다.
- 루트노드 -> 브랜치노드-> 리프노드 를 거쳐 탐색을 한다.
- 각 노드에는 키값이 여러개 있을수있다
- 인덱스 가 효율적인 이유:
  효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형잡힌 트리구조, 트리 깊이의 대수확장성
  - 대수확장성 : 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미
  * 인덱스가 한 깊이 증가하면 최대 인덱스 항목 수는 4배씩 증가한다.

### 4.5.3 인덱스 만드는 방법

데이터베이스 마다 다름

1. MySQL
   클러스터형 인덱스 : 테이블당 하나, 하나의 인덱스, primary key 옵션 or unique not null 옵션 으로 만들 수 있다. 하나의 필드 기반
   세컨더리 인덱스 : create index... 명령어 기반, 다양한 필드 기반

2. MongoDB : 도큐먼트 생성시 자동으로 ObjectID 형성, 기본키 + 세컨더리키 함께쓰는 복합 인덱스 설정 가능

### 4.5.4 인덱스 최적화 기법

(MongoDB 기반으로 설명)

1. 인덱스는 비용이다.
   인덱스 리스트, 컬렉션 순으로 두번 탐색하도록 강요

- 컬렉션 수정시 인덱스도 수정 필요

2. 항상 테스팅 하라

- 인덱스 최적화 기법이 서비스 마다 달라서 테스팅이 중요
- explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅, 걸리는 시간을 최소화 해야한다.

3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다.

- 여러 필드를 기반으로 조회할 때 복합 인덱스를 생성한다.
- 생성 순서에 따라 인덱스 성능이 달라진다.
- 같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 한다.

1. 같음 : ==, equal 쿼리는 가장 먼저 인덱스로 생성
2. 정렬 : 정렬에 쓰는 필드는 그다음 인덱스로 설정
3. 다중 값 : >,< ㄷㅇ 많은 값을 출력해야하는 쿼리에 쓰는 필드 설정
4. 카디널리티 : 유니크한 값의 정도, 높은 순으로 인덱스 생성 (ex. age, email중 email)

## 4.6 조인의 종류

조인 : 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것

- MySQL에서는 JOIN, MongoDB 에서는 lookup
  [ 종류 ]

1. 내부조인(inner join): 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기, null 불포함
2. 왼쪽 조인(left outer join): 왼쪽 테이블의 모든 행이 결과 테이블에 표기
3. 오른쪽 조인(right outer join): 오른쪽 테이블의 모든 행이 결과 테이블에 표기
4. 합집합 조인 (full outer join): 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기
   outer은 null 포함

### 4.6.1 내부 조인

: 두 테이블 간에 교집합

### 4.6.2 왼쪽 조인

: 테이블 B의 일치하는 부분의 레코드와 함께 테이블 A를 기준으로 완전한 레코드 집합 생성, 테이블 B에 일치하는 항목 없으면 해당 값은 null

### 4.6.3 오른쪽 조인

: 테이블 A의 일치하는 부분의 레코드와 함께 테이블 B를 기준으로 완전한 레코드 집합 생성, 테이블 A에 일치하는 항목 없으면 해당 값은 null

### 4.6.4 합집합 조인

양쪽 테이블에서 일치하는 레코드와 함께 테이블 A,B의 모든 레코드 집합 생성, 일치하는 항목 없으면 누락된 쪽에 null 값 포함

## 4.7 조인의 원리

### 4.7.1 중첩 루프 조인( Nested Loop Join )

중첩 for문 과 같은 원리로 조건에 맞는 조인을 한다. 랜덤 접근에 대한 비용 증가로 대용량 테이블에서는 사용하지 않는다.

- 중첩 루프 조인에서는 테이블을 작은 블록으로 나눠 블록 하나씩 조인하는 블록 중첩 루프 조인 방식을 사용

### 4.7.2 정렬 병합 조인

각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행한다.

- 조인 조건으로 <,> 등 범위 비교 연산자가 있을 때 사용

### 4.7.3 해시 조인

: 해시 테이블을 기반으로 조인하는 방법

- 두 개의 테이블 조인 시 하나의 테이블이 메모리에 온전히 들어갈 시 중첩 루프 조인보다 더 효율적임.

1. 빌드 단계
   : 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계

- 바이트가 더 작은 테이블을 기반으로 빌드
- 조인에 사용되는 필드가 해시 테이블의 키로 사용됨

2. 프로브 단계
   이 단계에서 레코드 읽기를 시작하며, 일치하는 레코드를 찾아서 결과값으로 반환한다.

- 각 테이블은 한번씩만 읽혀 중첩 루프 조인보다 보통 성능은 좋다. 사용 가능한 메모리양은 런타임시에 조정 가능
