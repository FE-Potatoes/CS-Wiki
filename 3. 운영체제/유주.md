# 유주

# 운영체제

## 3.1 운영체제와 컴퓨터

컴퓨터 = 운영체제(하드웨어 + 소프트웨어를 관리하는 일꾼) + CPU + 메모리 등

### 3.1.1 운영체제의 역할과 구조

#### 운영체제 역할

1. CPU 스케줄링과 프로세스 관리 : 프로세스 생성, 삭제 , CPU 등의 자원 할당 등을 관리
2. 메모리 관리 : 한정된 메모리를 프로세스에 얼마나 할당할지
3. 디스크 파일 관리 : 디스크 파일을 어떻게 보관할지
4. I/O 디바이스 관리 : 마우스, 키보드 등과 컴퓨터가 데이터를 주고받는 것 관리

#### 운영체제 구조

(- 유저 프로그램)

- 인터페이스 (GUI, CUI) -> 여기서부터
- 시스템콜 : 유저모드, 커널모드로 전환하는 명령어, 추상화 계층에 존재한다.
- 커널 (드라이버, 파일 시스템) -> 여기까지가 운영체제
  (- 하드웨어)

[ 용어 ]
GUI : 사용자가 전자장치와 상호 작용할 수 있도록 하는 사용자 인터페이스 형태 (동작 기반)
드라이버 : 하드웨어를 제어하기 위한 소프트웨어
CUI : 그래픽이 아닌 명령어로 처리하는 인터페이스
I/O 요청 : 입출력 함수, 데이터베이스, 네트워크, 파일 접근 등에 관한 일
드라이버 : 하드웨어를 제어하기 위한 소프트웨어
modebit : 1 또는 0의 값을 가지는 플래그 변수 ( 0은 커널 모드, 1은 유저 모드 )
유저 모드 : 유저가 접근할 수 있는 영역을 제한적으로 두며 컴퓨터 자원에 함부로 침범하지 못하게 하는 모드
커널 모드 : 모든 컴퓨터 자원에 접근할 수 있는 모드
커널 : 운영체제의 핵심 부분이자 시스템콜 인터페이스를 제공하며 보안, 메모리, 프로세스, 파일 시스템, I/O 등 운영체제의 중추적인 역할을 한다.

[ 시스템콜 ]
: 운영체제가 커널에 접근하기 위한 인터페이스

- 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 사용
- 유저 프로그램이 I/O 요청으로 트랩을 발동하면 올바른 요청인지 확인 후 유저 모드가 시스템콜을 통해 커널모드로 변환되어 실행된다.

### 3.1.2 컴퓨터의 요소

- CPU, DMA 컨트롤러, 메모리, 타이머, 디바이스 컨트롤러 등

#### CPU (Central Processing Unit)

: 산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 컴퓨터 장치

- 인터럽트에 의해 메모리에 존재하는 명령어를 해석하여 실행한다.
- 제어장치(CU, Control Unit) : 프로세스 조작을 지시하는 CPU의 한 부품
- 레지스터 : CPU 안에 있는 매우 빠른 임시기억장치
- 산술논리연산장치(ALU) : 덧셈, 뺄셈 같은 두 숫자의 산술 연산과 배타적 논리합,논리곱 같은 논리 연산 계산 회로

[ CPU 의 연산처리 ]

1. 제어장치가 메모리와 레지스터에 계산할 값을 로드한다.
2. 제어장치가 레지스터에 있는 값을 계산하라고 산술논리연산장치에 명령한다.
3. 제어장치가 계산된 값을 다시 레지스터에서 메모리로 계산한 값을 저장한다.

[ 인터럽트 ]
: 어떤 신호가 왔을 때 CPU를 잠깐 정지시키는 것

- 인터럽트 핸들러 함수가 실행된다.

1. 하드웨어 인터럽트 : 키보드,마우스 등 IO 디바이스에서 발생하는 인터럽트
   운영체제에 시스템콜을 요청해서 디바이스에 있는 작은 로컬 버퍼에 접근하여 일을 수행한다.
2. 소프트웨어 인터럽트 : 트랩, 프로세스가 시스템콜을 호출할 때 발동한다.

#### DMA 컨트롤러

: IO 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치

- CPU 부하를 막아주는 보조 일꾼
- 하나의 작업을 CPU와 DMA 컨트롤러가 동시에 하는 것을 방지한다.

#### 메모리

: 전자회로에서 데이터나 상태, 명령어 등을 기록하는 장치= 작업장

- 보통 RAM을 뜻함
- CPU 는 계산, 메모리는 기억을 담당한다.

#### 타이머

: 몇 초 안에는 작업이 끝나야 한다는 것을 정하고 특정 프로그램에 시간 제한을 다는 역할

#### 디바이스 컨트롤러

: 컴퓨터와 연결되어 있는 IO 디바이스들의 작은 CPU

## 3.2 메모리

### 3.2.1 메모리 계층

레지스터, 캐시, 메모리, 저장장치로 구성
=> 속도,용량 차이로 인한 병목현상 해

1. 레지스터 : CPU 안에있는 작은 메모리, 휘발성, 속도 빠름, 기억 용량 가장 적음
2. 캐시 : L1,L2,L3 캐시 , 휘발성, 속도 빠름, 기억 용량 적음
3. 주기억장치 : = RAM, 휘발성, 속도 보통, 기억 용량 보통
4. 보조기억장치 : = HDD, SSD, 비휘발성, 속도 낮음, 기억 용량 많음

램의 역할 : 하드디스크로부터 일정량의 데이터를 복사해서 임시 저장하고, 이를 필요 시마다 CPU에 빠르게 전달한다.
로딩 중인 경우는 하드디스크 또는 인터넷에서 데이터를 읽어 RAM으로 전송하는 과정이 끝나지 않은 것.

#### 캐시

: 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치 속도 차이에 따른 병목 현상을 줄이기 위한 메모리

- 데이터 접근 시간 해소, 다시 계산하는 시간 절약
- 메모리와 CPU 속도 차이를 레지스터 계층을 통해 해결
  => 계층과 계층 사이 속도 차이 해결을 위한 계층 = 캐싱 계층

[ 지역성 ]

1. 시간 지역성
   : 최근 사용한 데이터에 다시 접근하려는 특성
   ex. for문의 i

2. 공간 지역성
   : 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성
   ex. for문의 배열 arr

#### 캐시히트와 캐시미스

캐시히트 : 캐시에서 원하는 데이터를 찾음, 제어장치를 거쳐 가져온다. 빠르다.
캐시미스 : 데이터가 없을 때 주메모리에서 데이터를 찾음. 느리다.

[ 캐시매핑 ]
: 캐시가 히트되기 위해 매핑하는 방법

- CPU의 레지스터와 주메모리(램) 간에 데이터를 주고받을 때 레지스터가 캐시 계층으로써 역할을 해야한다.

1. 직접 매핑 : 순서대로 매핑하는것 , 출동할수있다.
2. 연관 매핑 : 순서 상관없이 관련 있는 캐시와 메모리를 매핑, 충돌이 적지만 느리다
3. 집합 연관 매핑 : 직접+연관 매핑 , 순서는 일치시키지만 집합을 둬서 저장하여 블록화한다.

[ 웹브라우저의 캐시 ]

- 보통 사용자의 커스텀한 정보나 인증 모듈 관련 사항들을 저장

1. 쿠키 : 만료기한이 있는 키-값 저장소

- same site 옵션을 strict 로 설정하지 않으면 다른 도메인에서 요청했을 때 자동 전송된다.=> CSRF 공격 방지
- ~4KB, 만료기한 설정 가능 (보통 서버에서)
- document.cookie로 쿠키를 볼 수 없게 httponly 옵션을 걸어야한다. => XSS 공격 방지

2. 로컬 스토리지

- 만료기한이 없는 키-값 저장소
- ~5MB, 웹브라우저를 닫아도 유지
- 클라이언트에서만 수정 가능

3. 세션 스토리지

- 만료기한이 없는 키-값 저장소
- ~5MB, 탭을 닫으면 데이터 삭제됨
- 클라이언트에서만 수정 가능

### 3.2.2 메모리 관리

#### 가상 메모리

: 메모리 관리 기법, 컴퓨터가 실제 이용 가능한 메모리 자원을 추상화하여 사용자들에게 매우 큰 메모리로 보이게 만드는 것
디스크에있는 일부공간을 램처럼 활용하는 것
램보다 더 큰 용량의 프로그램이여도 일부는 디스크에 필요한 부분만 램에 올려서 사용할 수 있따.

- 가상 주소가 메모리관리장치(MMU)에 의해 실제 메모리상에 있는 실제 주소로 변환된다.
- 가상 메모리는 가상 주소와 실제 주소가 매핑되어 있고, 프로세스의 주소 정보가 들어 있는 페이지 테이블로 관리된다.
- TLB 로 속도향상
  \*\* TLB : 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시

[ 스와핑 ]
: 메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고, 하드디스크의 일부분을 메모리처럼 불러와 쓰는 것

- 페이지 폴트가 발생하지 않은 것 처럼 만든다.
- 스와핑 발생시 페이지 테이블을 갱신시키고 해당 명령어를 다시 시작한다.

[ 페이지 폴트 ]
: 가상 메모리(프로세스의 주소 공간)에는 있지만 실제 메모리인 RAM 에는 없는 데이터나 코드에 접근할 때 발생한다.

#### 스레싱(thrashing)

: 메모리의 페이지 폴트율이 높은 것을 의미한다.
\*\* 페이지 : 가상 메모리를 사용하는 최소 크기 단위

- 컴퓨터의 심각한 성능 저하 초래
- 메모리에 많은 프로세스 진행시 스와핑이 많이 일어나서 발생

페이지 폴트 발생 => 스와핑 발생 => CPU 이용률 낮아짐 => 운영체제가 CPU 가 노는줄 알고 더 많은 프로세스를 메모리에 올림
=> 스레싱 발생
해결 방법 : 1. 메모리 늘리기 2. HDD를 SSD로 변경 3. 작업 세트 4. PFF

[ 작업 세트 ]
: 프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하는 것

- 탐색 비용과 스와핑을 줄일 수 있다.

[ PFF(Page Fault Frequency) ]
: 페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만든다.

- 상한선 도달시 프레임을 늘리고, 하한선 도달시 프레임을 줄인다.

#### 메모리 할당

- 메모리에 프로그램을 할당할 때는 시작 메모리 위치, 메모리의 할당 크기를 기반으로 할당한다.

1. 연속 할당
   : 메모리에 연속적으로 공간을 할당한다.

- 고정 분할 방식 : 메모리를 미리 나누어 관리
- 가변 분할 방식 : 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용 ( 최초/최적/최악 적합)

2. 불연속 할당
   : 메모리를 연속적으로 할당하지 않는다.

- 페이징 : 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당한다.
- 세그멘테이션 : 페이지 단위가 아닌 의미 단위인 세그먼트로 나누는 방식
- 페이지드 세그멘테이션 : 프로그램을 의미 단위인 세그먼트로 나눠 보안과 공유 측면에 강점을 두고, 동일한 크기의 페이지 단위로 나누는 것

#### 페이지 교체 알고리즘

- 오프라인 알고리즘 : 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘
- FIFO : 가장 먼저 온 페이지를 교체영역에 가장 먼저 놓는 방법
- LRU : least recently used, 참조가 가장 오래된 페이지를 바꾸는 방법
- NUR : not used recently,
- LFU : least frequently used, 가장 참조가 적은(적게 사용된) 페이지를 교체
  : 가장 덜 사용됐기때문에 , 최근성을 고려하지 않는다.
  초기 진입 장애(Cold Start): 새로 들어온 데이터는 사용 횟수가 낮아 바로 교체될 수 있어 캐시가 제대로 자리 잡기 어려워요.
  => aging 기법 : 사용빈도스& 가장마지막에 사용된 시점 함께 기록 하여 이걸 해결한다.

## 3.3 프로세스와 스레드

프로세스 : 컴퓨터에서 실행되고 있는 프로그램, CPU 스케줄링의 대상이 되는 작업
스레드 : 프로세스 내 작업의 흐름을 지칭

### 3.3.1 프로세스와 컴파일 과정

프로세스 : 프로그램이 메모리에 올라가 인스턴스화 된 것 (ex. 구글 -> 구글 크롬 프로세스)
컴파일러가 컴파일 과정을 통해 언어를 기계어로 번역
ex. 소스 코드 파일 -> 전처리 -> 컴파일러 -> 어셈블리어 -> 어셈블러 -> 목적코드 -> 라이브러리 + 링커 -> 실행 가능한 파일

- 전처리 : 소스 코드의 주석 제거, 헤더 파일을 병합하여 메크로를 치환
- 컴파일러 : 오류 처리, 코드 최적화 작업으로 어셈블리어로 변환
- 어셈블러 : 목적 코드로 변환
- 링커 : 라이브러리 함수 또는 다른 파일과 목적 코드를 결합하여 실행 파일을 만든다. (.exe, .out)

### 3.3.2 프로세스의 상태

- 생성 상태 (create) : fork(), exec() 함수로 프로세스가 생성된다.

* fork() : 부모 프로세스의 주소 공간을 그대로 복사하여 새로운 자식 프로세스를 생성하는 함수
* exec() : 새롭게 프로세스를 생성하는 함수

- 대기상태(ready) : 메모리 공간이 충분할 때만 메모리를 할당받는다. CPU 소유권이 넘어오길 기다린다.

- 대기 중단 상태(ready suspended) : 메모리 부족으로 일시 중단 상태

- 실행 상태 (running) : CPU 소유권과 메모리를 할당받고 인스트럭션을 수행중인 상태를 의미
  = CPU burst

- 중단 상태 (blocked) : 이벤트 발생 후 기다리며 프로세스가 차단된 상태 / 인터럽트가 발생했기때무에 중단

- 일시 중단 상태( blocked suspended): 대기 중단과 유사, 중단된 상태에서 프로세스를 시작하려했으나 메모리 부족으로 일시 중지

- 종료 상태 (terminated) : 메모리와 CPU 소유권을 모두 놓고 가는 상태
  자연스러운 종료, 자발적 종료(abort)

### 3.3.3 프로세스의 메모리 구조

메모리 할당 구조
스택+힙(동적 영역) / 데이터 영역+코드 영역(정적 영역)

#### 스택과 힙

- 동적할당 = 런타임 단계에서 메모리를 할당받는다.
- 스택은 지역변수,매개변수,실행되는 함수에 의해 늘거나 줄어드는 메모리 영역
- 특정 정보가 스택에 계속 쌓인다.

- 힙은 동적으로 할당되는 변수

#### 데이터 영역과 코드 영역

- 정적 할당되는 영역 = 컴파일 단계에서 메모리를 할당한다.
- 데이터 영역: 전역 변수, static , const 로 선언, 초기화 값 없거나 0
- 코드 영역 : 전역 변수, static , const 로 선언, 초기화 값이 0이 아님

### 3.3.4 PCB (process control block)

: 운영체제에서 프로세스에 대한 메ㅏ데이터를 저장한 데이터, 프로세스 제어 블록

\*\* 메타데이터 : 데이터에 관한 구조화된 데이터, 대량의 정보 가운데 찾고 있는 정보를 효율적으로 찾아내기 위해 사용

#### PCB의 구조

- 프로세스 스케줄링 상태 : 프로세스가 CPU 소유권을 얻은 이후의 상태, 준비,일시중단 등
- 프로세스 ID
- 프로세스 권한 : 컴퓨터 자원 or I/O 디바이스 권한 정보
- 프로그램 카운터 : 실행할 다음 명령어의 주소에 대한 포인터
- CPU 레지스터 : 프로세스 실행을 위해 저장해야 할 레지스터 정보
- CPU 스케줄링 정보 : CPU 스케줄러에 의해 중단된 시간 정보
- 계정 정보 : 프로세스 실행에 사용된 CPU 사용량, 실행한 유저 정보
- I/O 상태 정보 : 프로세스에 할당된 I/O 디바이스 목록

#### 컨텍스트 스위칭

: PCB 를 기반으로 프로세스의 상태를 저장하고 로드시키는 과정

- 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생한다.
- (싱글코어 기준으로) 컴퓨터는 한 시점에서 하나의 프로세스가 구동되며, 많은 프로세스가 동시에 구동되는 것 처럼 보이는 것은 다른 프로세스와의 컨텍스트 스위칭이 아주 빠른 속도로 이루어지기 때문이다. 현대는 멀티코어의 CPU 를 가져 해당되지 않음..

[ 캐시미스 ]
: 컨텍스트 스위칭에 드는 비용

- 프로세스가 가지고 있는 메모리 주소를 비우는 캐시클리어 과정에서 발생

### 3.3.5 멀티프로세싱

: 여러 개의 프로세스, 동시에 두가지 이상의 일을 수행하는 것

- 하나 이상의 일을 병렬로 처리 가능

#### 웹 브라우저

- 멀티프로세스 구조

1. 브라우저 프로세스 : 주소 표시줄, 북마크, 뒤로 가기 앞으로 가기 버튼, 네트워크 요청이나 파일 접근 권한 담당
2. 렌더러 프로세스 : 웹 사이트가 보이는 부분의 모든 것을 제어
3. 플러그인 프로세스 : 웹 사이트에서 사용하는 플러그인을 제어
4. GPU 프로세스 : GPU 를 이용해서 화면을 그리는 부분을 제어

#### IPC (Inter Process Communication)

: 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘

- 예시 : 클라이언트에서 데이터 요청, 서버에서 응답 하는 것, 공유 메모리, 파일, 소켓, 익명 파이프, 명명 파이프, 메시지 큐 등

[ 공유 메모리 ]
: 여러 프로세스에 동일한 메모리 블록에 대한 접근 권한이 부여되어 프로세스가 서로 통신할 수 있도록 공유 메모리를 생성해서 통신하는 것

- 메모리 자체를 공유하기 때문에 불필요한 데이터 복사의 오버헤드가 발생하지 않아 가장 빠르다
- 동기화가 필요하다
- 하드웨어 관점에서는 CPU가 접근할 수 있는 큰 랜덤 메모리인 RAM 을 뜻하기도 한다.

[ 파일 ]
: 디스크에 저장된 데이터 또는 파일 서버에서 제공한 데이터

[ 소켓 ]
: 동일한 컴퓨터의 다른 프로세스나 네트워크의 다른 컴퓨터로 네트워크 인터페이스를 통해 전송하는 데이터 (TCP, UDP)

[ 익명 파이프 ]
: 프로세스 간에 FIFO 방식으로 읽히는 임시 공간인 파이프를 기반으로 데이터를 주고 받으며, 단방향 방식의 읽기 전용, 쓰기 전용 파이프를 만들어서 작동하는 방식

[ 명명된 파이프 ]
: 파이프 서버와 하나 이상의 파이프 클라이언트 간의 통신을 위한 명명된 단방향 또는 양방향 파이프

- 여러 파이프 동시 사용 가능
- 컴퓨터의 프로세스 끼리, 혹은 다른 네트워크 상의 컴퓨터와도 통신 가능

[ 메시지 큐 ]
: 메시지를 큐 데이터 구조 형태로 관리하는 것

- 사용방법이 간단하다

### 3.3.6 스레드와 멀티스레딩

#### 스레드

: 프로세스의 실행 가능한 가장 작은 단위

- 프로세스는 여러 스레드를 가질 수 있다.
- 코드, 데이터, 힙을 스레드끼리 공유한다.

#### 멀티스레딩

: 프로세스 내 작업을 여러 개의 스레드, 멀티스레드로 처리하는 기법

- 스레드끼리 자원을 공유하여 효율성이 높다
- 장점 : 각각 따로 처리 가능, 동시성
- 단점 : 스레드에 문제 생길시 다른 스레드에도 영향
- ex. 웹 브라우저의 렌더러 프로세스

### 3.3.7 공유 자원과 임계 영역

#### 공유 자원

: 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수 등

\*\* 경쟁 상태 : 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황

- 동시 접근시 접근의 타이밍이나 순서 등이 결과에 영향을 줄 수 있다.

#### 임계 영역

: 둘이 상의 프로세스, 스레드가 공유 자원에 접근 할 때 순서 등의 이유로 결과가 잘라지는 코드 영역

- 해결 방법: 뮤텍스, 세마포어, 모니터
  상호 배제, 한정 대기, 융통성 조건을 만족한다.
  잠금(lock)의 메커니즘을 사용한다.
  상호 배제 : 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다.
  한정 대기 : 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안된다.
  융통성 : 임계 영역이 비어있으면 어떠한 프로세스도 들어갈 수 있으며 프로세스끼리 서로 방해하지 않는다.

[ 뮤텍스 ]
: 프로세스나 스레드가 공유자원을 lock()을 통해 잠금 설정하고 사용한 후에는 unlock()을 통해 잠금 해제하는 객체

- 잠긴 코드 영역에는 접근 불가
- 뮤텍스의 상태는 잠금 또는 잠금 해제

[ 세마포어 ]
: 일반화된 뮤텍스, 간단한 정수값과 두가지 함수 wait 및 signal 로 공유자원에 대한 접근을 처리

- wait(): 자신의 차례가 올때까지 기다리는 함수, 프로세스나 스레드가 공유자원에 접근시 수행됨
- signal(): 다음 프로세스로 순서를 넘겨주는 함수, 프로세스나 스레드가 공유자원 해제시 수행됨
- 종류
  바이너리 세마포어 : 0,1 두가지 값만 가진다.
  카운팅 세마포어 : 여러 개의 값을 가진다. 여러 자원에 대한 접근을 제어한다.

[ 모니터 ]
: 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스 제공

### 3.3.8 교착 상태

: 두개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태

[ 교착 상태의 원인 ]

- 상호 배제 : 한 프로세스가 자원을 독점
- 점유 대기 : 특정 프로세스가 점유한 자원을 다른 프로세스가 요청
- 비선점 : 다른 프로세스의 자원을 강제적으로 가져올 수 없다
- 환형 대기 : 서로가 서로의 자원을 요구

[ 교착 상태 해결 방법 ]

1. 자원 할당시 애초에 조건이 성립하지 않도록 설계
2. 교착 상태 가능성이 없을때만 자원 할당, 프로세스 당 요청할 자원의 최대치로 할당 가능 여부를 파악하는 은행원 알고리즘 사용
3. 교착 상태 발생시 사이클이 있는지 찾아보고 프로세스를 하나씩 지운다.
4. 교착 상태 발생시 사용자가 작업을 종료

## 3.4 CPU 스케줄링 알고리즘

### 3.4.1 비선점형 방식

: 프로세스가 스스로 CPU 소유권을 포기하는 방식, 강제로 프로세스를 중지하지 않는다.

#### FCFS (First come, Fist served)

: 가장 먼저 온 것을 가장 먼저 처리하는 알고리즘

- 길게 수행되어 준비 큐에서 오래 기다리는 현상이 발생하는 단점이 있음

#### SJF (Shortest Job First)

: 실행시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘

- 긴 시간을 가진 프로세스가 실행되지 않는 현상 발생

#### 우선순위

: SJF의 단점을 오래된 작업일수록 우선순위를 높이는 방법을 사용하여 보완한 알고리즘

### 3.4.2 선점형 방식

: 현대 운영체제가 쓰는 방식으로 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시켜버리고 강제로 다른 프로세스에 CPU 소유권을 할당하는 방식

#### 라운드 로빈

: 현대 컴퓨터가 쓰는 선점형 알고리즘 스케줄링 방법, 각 프로세스에 동일한 할당 시간을 주고 그 시간안에 끝나지 않으면 다시 준비 큐의 뒤로 가는 알고리즘

#### SRF

: 중간에 실행 시간이 더 짧은 작업이 들어와도 기존 짧은 작업을 모두 수행하고 다음 짧은 작업을 이어나가는 SJF 와 달리 기존 프로세스를 중지하고 새로운 프로세스를 수행하는 알고리즘

#### 다단계 큐

: 우선순위에 따른 준비 큐를 여러개 사용하고, 큐마다 라운드 로빈이나 FCFS 등 다른 스케줄링 알고리즘을 적용한 것

- 스케줄링 부담이 적지만 유연성이 떨어진다.
