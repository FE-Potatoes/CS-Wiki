# 경훈

## 5.1 복잡도
### 5.1.1 시간 복잡도
- 시간 복잡도는 알고리즘이 수행되는데 걸리는 시간을 수학적으로 표현한 것
- 빅오 표기법: 입력 크기에 대해 어떠한 알고리즘이 실행되는 것에 걸리는 시간, 최악의 경우에 대한 성능을 나타냄

### 5.1.2 공간 복잡도
- 공간 복잡도는 프로그램을 실행시켰을 때 필요로 하는 자원의 양을 의미

## 5.2 선형 자료 구조

- 요소가 일렬로 나열되어 있는 자료구조

### 5.2.1 연결 리스트

- 노드와 포인터로 연결된 자료구조입니다. 삭제 O(1), 탐색 O(n)
  - 싱글 연결 리스트: 노드에 next 포인터만 가지고 있음
  - 이중 연결 리스트: 노드에 prev, next 포인터 가지고 있음
  - 원형 이중 연결 리스트: 이중 연결 리스트와 동일하고 마지막 노드와 헤드가 연결되어 있음

### 5.2.2 배열
- 요소가 나열된 자료구조, 삽입 삭제 O(n), 탐색 O(1)

### 5.2.3 벡터
- 동적으로 요소를 할당할 수 있는 동적 배열
- 컴파일 시점에 개수를 모른다면 벡터 사용
- 매번 크기를 늘리는 것이 아닌 2의 제곱승 + 1만큼 늘어남

### 5.2.4 스택
- LIFO 자료구조 삽입 삭제 O(1), 탑색에 O(n)

### 5.2.5 큐
- FIFO 자료구조 삽입 삭제 O(1), 탑색에 O(n)

## 5.3 비선형 자료 구조
### 5.3.1 그래프
- 정점과 간선으로 이뤄진 자료 구조
- 가중치: 간선과 정점 사이에 가는 비용을 의미

### 5.3.2 트리
- 루트: 최상단에 있는 노드 (출발점)
- 간선: 노드와 노드를 연결하는 선
- 부모/자식 관계: 어떤 노드 A 밑에 B가 있으면, A는 B의 부모, B는 A의 자식
- 리프 노드: 자식이 없는 노드
- 깊이: 루트에서 해당 노드까지의 거리
- 서브트리: 어떤 노드를 루트로 하는 작은 트리
- 높이: 해당 노드에서 가장 아래 리프 노드까지의 거리

| 종류                            | 설명                               |
| ----------------------------- | -------------------------------- |
| 이진 트리       | 각 노드가 최대 두 개의 자식(왼쪽, 오른쪽)을 가짐    |
| 이진 탐색 트리            | 왼쪽은 작은 값, 오른쪽은 큰 값을 저장하는 이진 트리   |
| 완전 이진 트리                  | 마지막 레벨을 제외하고 모두 꽉 찬 이진 트리        |
| 포화 이진 트리                  | 모든 노드가 자식 노드 0개 또는 2개를 가지는 이진 트리 |
| 균형 이진 트리 | 왼쪽/오른쪽 서브트리 높이 차이를 일정 이하로 유지     |
| 힙             | 최대값 또는 최소값이 루트에 있는 완전 이진 트리      |
| 트라이                 | 문자열 탐색에 최적화된 트리 (예: 자동완성)        |
| N-진 트리       | 노드가 최대 N개의 자식을 가질 수 있는 트리        |

### 5.3.3 힙

- 완전 이진 트리
- 마지막 레벨을 제외하고 모든 레벨이 가득 차 있음
- 배열로 구현하기 쉬움
- 삽입/삭제 시 항상 힙 속성을 재정렬하며 유지
- 탐색은 느리다
- 정렬된 구조가 아니라서 임의 값 탐색은
- 하지만 최댓값/최솟값은 O(1)로 빠르게 접근 가능

| 종류                  | 설명                         |
| ------------------- | -------------------------- |
| 최소 힙 | 부모 노드 ≤ 자식 노드 → 루트가 항상 최소값 |
| 최대 힙  | 부모 노드 ≥ 자식 노드 → 루트가 항상 최대값 |

### 5.3.4 우선순위 큐
- 큐: 먼저 들어온 순서대로 처리(FIFO)
- 우선순위 큐: 우선순위가 높은 요소를 먼저 처리함

- 내부적으로 Heap을 사용해 구현하는 경우가 많음
- 예: 긴급한 작업, 다익스트라 알고리즘 등

| 연산       | 시간       |
| -------- | -------- |
| 삽입       | O(log n) |
| 꺼내기      | O(log n) |
| 최소/최대 확인 | O(1)     |

### 5.3.5 맵

- Key-Value 쌍을 저장하는 자료구조
- JS에서는 Map 객체로 사용
- 순서 보장: 삽입 순서대로 순회 가능
- 객체보다 더 유연한 키 사용 가능

### 5.3.6 셋

- 중복 없는 값들의 집합
- JS에서는 Set 객체 사용
- 중복 제거에 유리
- 순회 가능, 삽입 순서 기억

### 해시 테이블

- Key를 해시 함수로 변환해 Index에 저장하는 자료구조
- JS에서 Object, Map은 내부적으로 해시 테이블 기반

```js
const obj = { a: 1 };
obj['b'] = 2;
```