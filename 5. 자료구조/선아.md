# 선아

### 시간복잡도

- 입력 크기에 대해 어떠한 알고리즘이 실행되는 데 걸리는 시간

### 공간복잡도

- 프로그램을 실행시켰을 떄 필요로 하는 지원 공간의 양

### 빅오 표기법

- 입력 크기 n이 커질 때 알고리즘 성능이 얼마나 증가하는지
- 최악의 경우를 기준으로 분석

### 선형 자료 구조

1. 연결 리스트
    - 데이터를 감싼 노드를 포인로 연결하여 공간적인 효율성을 극대화시킨 자료 구조
    - 삽입: O(1) / 삭제: O(1) / 탐색: O(n)
    - 링크드 리스트 종류
        
        ![image](https://github.com/user-attachments/assets/2fdd0ffa-fb30-4b00-84ea-f97bfbbd9709)

      1. 싱글 연결 리스트: next 포인터만 존재
      2. 이중 연결 리스트: next, prev 포인터 존재
      3. 원형 이중 연결 리스트: 마지막 노드의 next 포인터가 첫 노드를 가리키는 이중 연결 리스트
    - 브라우저 히스토리 관리에 사용 → undo, redo 하기 위해
2. 배열
    - 같은 타입의 변수들을 인접한 메모리 위치에 저장해둔 집합
    - 삽입: O(n) / 삭제: O(n) / 랜덤접근: O(1)
    - CPU 페이지 테이블에 사용

cf) 연결 리스트 vs 배열

- 랜덤 접근이 많은 경우: 배열 사용
- 삽입/삭제가 빈번한 경우: 연결리스트 사용

3. 벡터
    - 동적으로 요소를 할당할 수 있는 동적 배열
    - 랜덤 접근 가능
    - 맨 뒤 요소 삽입&삭제: O(1) / 랜덤 요소 삽입&삭제: O(n) / 랜덤접근: O(1)

4. 스택
    - LIFO 구조
    - 삽입: O(1) / 삭제: O(1) / 탐색: O(n)

5. 큐
    - FIFO 구조
    - 삽입: O(1) / 삭제: O(1) / 탐색: O(n)
    - 프로세스 레디 큐, 네트워크 접속을 기다리는 행렬, 캐시에 사용됨

### 비선형 자료 구조

- 일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조

1. 그래프
    - node, edge로 이루어진 집합
    - 가중치: 간선과 정점 사이에 드는 비용

2. 트리
    - 계층 구조를 가지는 그래프
    - cycle 없음
    - 구성 요소
        - 루트 노드: 트리에서 가장 위에 있는 시작 노드
        - 내부 노드: 자식을 하나 이상 가진 노드
        - 리프 노드: 자식이 없는 노드
    - 용어
        - 깊이: 루트노드에서 해당 노트까지 도달하기 위한 간선의 수
        - 높이: 어떤 노드에서 가장 멀리 있는 리프 노드까지의 간선 수
        - 서브 트리: 트리 내의 하위 집합
    - 이진 트리
        - 자식의 노드 수가 두 개 이하인 트리
        - full binary tree: 자식 노드가 0/2개인 이진 트리
        - complete binary tree: 왼쪽에서부터 채워져 있는 이진 트리
        - 이진 탐색 트리 binary search tree
            - 노드의 오른쪽 서브 트리는 노드 값보다 큰 값이 존재
            - 노드의 왼쪽 서브 트리는 노드 값보다 작은 값이 존재
            - 탐색: 평균 O(logn), 최악 O(n)
            - 단점: 루트 노드를 잘못 설정하면 한 쪽으로 치우쳐진 이진 트리가 될 수 있음 → 탐색 시간 증가
        - AVL 트리
            - 선형 트리가 되는 것을 방지하고 스스로 균형을 유지하는 이진 탐색 트리
            - 두 자식 서브트리의 높이가 항상 최대 1만큼 차이남
            - 삽입: O(logn) / 삭제: O(logn) / 탐색: O(logn)
            - 불균형 4가지
                1. LL(Left Left)
                    
                    ![image](https://github.com/user-attachments/assets/053a49f7-81ff-451b-81a2-71e62e58d228)

                    - y가 z의 왼쪽 자식 노드이고, x는 y의 왼쪽 자식 노드인 경우
                    - right rotation 실행
                2. RR(Right Right)
                    
                    ![image](https://github.com/user-attachments/assets/187f8cb0-0c34-451b-9827-047731eb30f1)

                    - y는 z의 오른쪽 자식 노드이고, x는 y의 오른쪽 자식 노드인 경우
                    - left rotation 실행
                3. LR(Left Right)
                    
                    ![image](https://github.com/user-attachments/assets/e91f260d-be03-4731-a7c2-83d9885bc6aa)

                    - y가 z의 왼쪽 자식 노드이고, x가 y의 오른쪽 자식 노드인 경우
                    - left rotation → right rotation 두 번 수행
                4. RL(Right Left)
                    
                    ![image](https://github.com/user-attachments/assets/6334db59-b303-442f-8c46-f98714000cfd)
                    
                    - y가 z의 오른쪽 자식 노드이고, x가 y의 왼쪽 자식 노드인 경우
                    - right rotation → left rotation 두번 수행
                      
                - [참고 링크](https://yoongrammer.tistory.com/72)
    - 힙
        - 완전 이진 트리 기반 자료 구조
        - min heap: 루트 노드의 값이 가장 작은 트리
        - max heap: 루트 노드의 값이 가장 큰 트리
    - 우선순위 큐
        - 대기열에서 우선순위가 높은 요소가 우선순위가 낮은 요소보다 먼저 제공되는 자료 구조
        - 힙 기반 자료 구조
3. 맵
    - key-value 조합으로 형성된 자료 구조
4. 세트
    - 고유한 요소를 저장하는 컨테이너 → 중복 요소 X
5. 해시 테이블
    - 대용량 데이터를 유한한 개수의 해시 값으로 매핑한 테이블
    - 삽입&삭제&탐색 시 평균 O(1) 시간 복잡도를 가짐

