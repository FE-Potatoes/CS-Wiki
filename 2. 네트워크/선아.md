# 2.1 네트워크 기초

### 처리량

- 초당 전송/수신 비트수
- 단위: bps
- 트래픽, 네트워크 장치 간 대역폭, 네트워크 에러, 장치 하드웨어 스펙의 영향을 받음

### 지연시간

- 요청이 처리되는 시간 = 어떤 메시지가 두 장치를 왕복하는 데 걸린 시간
- 유/무선, 패킷 크기, 라우터의 패킷 처리 시간의 영향을 받음

### 네트워크 토폴로지

- 네트워크 내에서 노드와 링크 연결 방식
- 병목 현상 해결을 위해 네트워크 구조를 아는 것이 중요
- 종류
    1. 트리 토폴로지 = 계층형 토폴로지
        - 트리 형태의 네트워크 구성
        - 노드 추가/삭제가 쉬움
        - 특정 노드에 트래픽이 집중될 때 하위 노드 영향 O
    2. 버스 토폴로지
        - 중앙 통신 회선 하나에 여러 개의 노드가 연결되어 있는 네트워크
        - LAN에서 사용하는 구조
        - 장점
            1. 설치 비용이 적음
            2. 신뢰성 우수
            3. 노드 추가/삭제가 쉬움
        - 단점
            1. 스푸핑 발생 가능
                - 공격자가 IP주소를 위조하여 메시지 전송 → 수신자는 위조된 IP주소로 메시지 응답 → 해당 IP주소는 원치 않은 데이터를 수신함 (DoS 공격)
    3. 스타 토폴로지
        - 중앙에 있는 노드와 모두 연결된 네트워크 구성
        - 장치 간 직접적인 연결이 없고, 모든 통신은 중앙 노드를 통해 전달됨
        - 장점
            1. 에러 탐지 용이
            2. 패킷 충돌 발생 가능성 적음 ← 모든 장치가 중앙 노드와 각각 독립된 1:1 연결을 맺고 있기 때문
        - 단점: 중앙 노드에 장애 발생시, 전체 네트워크를 사용할 수 없게 됨
    4. 링형 토폴로지
        - 각 노드가 양 옆의 두 노드와 연결되어 있는 구성 방식
        - 보통 한 방향을 정해서, 그 방향으로만 데이터를 보냄
        - 장점
            1. 네트워크 상 손실이 적음 ← 목적지가 자신이 아니면, 프레임을 다음 노드에 전달하는 단순한 방식을 사용하기 때문에, 네트워크가 확장되어도 중간 노드가 복잡한 판단을 하지 않음
            2. 노드의 고장 발견을 쉽게 찾을 수 있음 ← 한 방향으로 보내다가 어느 지점에서 끊기면, 그 노드가 문제이기 때문
        - 단점
            1. 회선 장애 발생시 전체 네트워크에 영향 발생
            2. 네트워크 구성 변경이 어려움 ← 노드 추가/삭제시 함께 연결된 다른 노드의 회선까지 함께 건드려야 하기 때문
    5. 메시 토폴로지 = 망형 토폴로지
        - 그물망 구조
        - 장점
            1. 한 단말 장치에 장애가 발생해도 전체 네트워크 영향 X ← 경로가 여러 개 존재하기 때문
            2. 트래픽 분산 처리 가능
        - 단점
            1. 노드 추가 어려움
            2. 구축 비용 고가

## 네트워크 분류

### LAN (Local Area Network)

- 근거리 통신망 = 같은 IP 대역을 사용하는 네트워크 매체들을 묶는 네트워크
- 허브/스위치로 연결된 소규모 네트워크
- MAN, WAN보다 높은 안정성 & 속도
- 유선 매체 - Ethernet 케이블 사용. 무선 매체 - Wi Fi

### MAN (Metropolitan Area Network)

- 2개 이상의 LAN으로 이루어진 네트워크
- 각 LAN은 라우터, 브리지 등으로 연결됨
- 전송 매체: 광섬유, 동축 케이블
- 이중 버스 토폴로지 사용

cf) 라우터: 패킷 위치를 기반으로 최적의 경로를 지정하여, 그 경로를 따라 패킷을 다음 장치로 이동시키는 장치

### WAN

- 국가 간 통신망
- Internet

# 2.2 TCP/IP 4계층 모델

<img width="707" alt="image" src="https://github.com/user-attachments/assets/654390ea-7fec-47bc-860f-cfc662fe7dd8" />

### Application Layer

- 응용 프로그램이 사용되는 프로토콜 계층
- FTP, HTTP, SSH, SMTP, DNS
- 처리 장치: L7 스위치
    - 역할: 로드밸런서(서버 부하 분산 기기)
    - URL, 서버, 캐시, 쿠키를 기반으로 트래픽 분산
    - 바이러스, 불필요한 외부 데이터를 걸러내는 필터링 기능

### Transport Layer - TCP

- transmission control protocol
- 연결 지향 방식. 가상회선 패킷 교환 방식
    - 패킷 전송을 위한 논리적 경로를 배정
    - 3 way handshake로 연결 → 4 way handshake로 해제
    - 시작: 3 way handshake - 정상적인 시작 과정
        1. SYN 전송
        2. SYN 수신 후 SYN-ACK 전송
        3. SYN-ACK 수신 후 ACK 전송 (연결됨)
    - 종료: 4 way handshake
        
        <img width="651" alt="image" src="https://github.com/user-attachments/assets/5d662bdd-1bda-4d52-97da-c8694f570527" />

        - RST: TCP 연결 강제 종료시 사용. 연결 즉시 종료
        - 정상적인 종료 과정
            1. 클라이언트가 FIN 전송
                - 클라이언트: FIN-WAIT-1 상태가 됨
            2. 서버에서 FIN 수신 후 ACK 전송
                - 서버: CLOSE-WAIT(상대방의 FIN(종료 요청)을 받은 상태)
                - 클라이언트: FIN-WAIT-2 상태가 됨 (Half Close 상태)
                    
                    → 나는 더 이상 보낼 게 없지만, 서버가 보낼 데이터는 더 받을 수 있는 상태
                    
            3. 서버가 FIN 전송
                - 클라이언트 상태: TIME-WAIT
            4. 클라이언트가 FIN 수신 후 ACK 전송
- 순서 보장
    - 패킷마다 sequence number를 가지고 있음
    - 수신 측에서 sequence number를 보고 정렬 + 누락 체크
- 흐름제어  : 송/수신 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지
    - 수신측이  송신측에게 자신의 상태를 지속적으로 알림
    - 수신측에서 데이터 받을 준비가 되었을 때 송신측에서 패킷을 보냄
    - 왜? 송신속도 > 수신속도라면 전송된 패킷이 drop되는 경우가 발생하기 때문
    - 종류
        - stop and wait: 매번 전송한 패킷에 대한 확인 응답(ack)을 받아야 그 다음 패킷 전송
        - sliding window: 수신측이 받을 수 있는 데이터의 양을 알려주기 때문에 패킷마다 응답을 받을 필요 없음
            1. 예) 송신측은 총 6개의 패킷을 보내야 함. 수신측으로부터 받은 윈도우크기와 네트워크 상황을 고려하여 자신의 윈도우크기를 지정
            2. 윈도우크기만큼 수신측에게 전송
            3. 수신측은 `내가 지금까지 연속으로 잘 받은 마지막 seq num + 1`을 송신측에게 보냄
            4. 송신측은 윈도우를 움직여서 수신측에서 원하는 seq num을 가진 패킷부터 또 보냄
     
            [참고 링크](https://evan-moon.github.io/2019/11/22/tcp-flow-control-error-control/)
          
### Transport Layer - UDP

- UDP = user datagram protocol
- 데이터그램 기반 프로토콜 → handshake 과정 필요 X
    - 패킷 간 순서가 정해져 있지 않음
    - 패킷의 목적지만 정해져 있다면 중간 경로는 알바 아님

### Transport Layer

- 전송 단위: TCP - 세그먼트 / UDP - 데이터그램
- 처리 장치: L4 스위치
    - 역할: 로드밸런서
    - IP 주소 + 포트번호 기반으로 트래픽 분산
    - 스트리밍 관련 서비스에서는 사용 불가 → 이전에 이 클라이언트 요청을 어느 서버로 보냈었는지를 기억해서 그 다음에도 같은 서버로 보내줘야 하는데, UDP(주로 스트리밍 서비스)는 비연결형 방식이라 이전 기록을 기억/추적하기가 어려움. 그러나 UDP에서 완전히 불가능한 것은 아니다.

### Network Layer

- 네트워크 패킷을 IP주소로 전송하기 위해 사용되는 계층
- 상대방이 제대로 받았는지 확인하지 않는 비연결형적인 특징을 가지고 있음
- IP, ARP, ICMP
- 전송 단위: 패킷
- 처리 장치: 라우터 & L3 스위치
    - 여러 개의 LAN을 구분하고, 연결시켜주는 장비
    - 경로 최적화 기능을 가지고 있음

### Data Link Layer

- 이던세 프레임을 통해 에러 확인, 흐름제어, 접근제어를 담당하는 계층
- 전선, 광섬유, 무선으로 데이터 전달
- 전송 단위: 프레임
- 처리 장치
    1. L2 스위치
        - MAC 주소 테이블을 통해 장치들의 MAC 주소 관리
        - 연결된 장치로부터 패킷이 왔을 때 패킷 전송을 담당함
        - IP(X) MAC(O) 주소 기반 라우팅
    2. 브리지
        - 하나의 LAN 안에서 세그먼트들을 상호 접속할 수 있게 하는 통신망 연결 장치
        - 통신망 범위를 확장할 때 사용
        - cf) 세그먼트란? 하나의 LAN 안에서 충돌이 발생할 수 있는 영역
        - cf) 여기서의 충돌: 같은 네트워크 매체를 여러 장비가 동시에 사용하려고 해서 데이터 신호가 겹쳐지는 현상. 전송 회선을 공유할 때, 누군가 데이터 보내는 동안 다른 데이터가 겹치면 전기신호가 겹쳐서 해석 불가능한 신호가 되어버림 → 충돌을 피하기 위해 LAN을 여러 개의 세그먼트로 나누고 그걸 브리지로 이어서 충돌을 피한다
    3. AP
        - 패킷 복사 기기
        - 무선 기기가 유선 네트워크에 접속할 수 있게 해주는 장치

### Physical Layer

- 0/1로 이루어진 이진 데이터 전송
- 처리 장치
    1. NIC = LAN 카드 (1-2 계층 통합 담당)
        - 기기를 네트워크에 연결해주는 장치
        - LAN 카드마다 고유의 MAC 주소를 가지고 있음
    2. 리피터:
        - 약해진 신호를 재생하고 증폭해서 더 먼 거리로 보내주는 장치
        - 유선 네트워크의 거리 한계를 극복하기 위해 사용 → 최근에는 광케이블 사용으로 잘 사용하지 X

### 캡슐화 & 비캡슐화

- 캡슐화: 상위 계층의 헤더와 데이터를 하위 계층의 데이터 부분에 포함시키고 + 해당 계층의 헤더를 삽입하는 과정
- 비캡슐화: 하위 → 상위로 가며 각 계층의 헤더를 제거하는 과정

# 2.4 IP 주소

### ARP(Address Resolution Protocol)

⇒ IP 주소와 MAC 주소를 매칭시키기 위한 프로토콜

- 왜 IP 주소를 MAC 주소로 매칭해야 할까?
    - 하나의 LAN 내의 Layer 2 통신할 때 IP 주소를 목적지로 지정하지만, 실제로는 MAC 주소를 이용해 목적지를 찾기 때문
- 왜 IP주소/MAC주소 중 하나만 사용하지 않고, 둘 다 사용해야 할까?
    - IP주소만 사용한다면 IP 주소는 쉽게 변경 가능하기 때문에, MAC 주소라는 고유 식별자가 없다면 누군가 IP 주소를 의도적으로 도용해도 구분할 수 없음
    - MAC 주소만 사용한다면, IP 주소와 다르게 연속적인 값으로 표현할 수 없기 때문에 기기의 MAC 주소를 일일히 라우팅 테이블에 입력해야 해서 라우팅 테이블 크기가 매우 커짐
- ARP Table
    - IP 주소와 MAC 주소를 일대일 대응하여 정리한 표
    - 기기마다 개별로 관리됨 → 같은 LAN에 속한 기기들이더라도, 서로 알고 있는 정보가 다름
    - 생성 과정
        1. Broadcast (FF:FF:FF:FF:FF:FF) ARP Request(Who has 192.168.1.3? Tell 192.168.1.1)를 날림 → 같은 LAN 내 모든 기기에 전달
        2. 목적지 기기가 Unicast를 통해 ARP Response를 보냄
        3. 송신자가 ARP Response를 받아 자신의 ARP Table에 IP, MAC 주소를 적음
        4. 이후 통신부터는 ARP Request 없이 ARP Table 사용하여 그 기기와 바로 통신 가능

cf) IP 주소 vs MAC 주소

- IP 주소
    - 네트워크 상의 “논리적” 주소 → 네트워크 변경시 바뀔 수 있음
    - 네트워크 계층에서 사용하는 주소
    - 계층적/연속적인 구조 + 서브넷, 서브넷 마스크를 사용하여 블록 단위 라우팅 가능
- MAC 주소
    - 장비의 “물리적 고유” 주소 → 네트워크 변경시에도 바뀌지 않음
    - 데이터 링크 계층에서 사용하는 주소
    - 무작위/비연속적인 48비트 주소 → 정렬, 분류, 라우팅이 어려움

cf) Broadcast, Unicast

- Broadcast(FF:FF:FF:FF:FF:FF): 송신 호스트가 전송한 데이터가 네트워크에 연결된 모든 호스트에 전송되는 방식
- Unicast: 고유 주소로 식별된 하나의 네트워크 목적지에 1:1로 데이터를 전송하는 방식

### IP 주소  체계

- 라우팅 테이블
    - 목적지에 도달하기 위해 거쳐야 할 다음 라우터 정보를 가진 테이블
    - 가장 단순한 방식은 홉바이홉(hop-by-hop) 라우팅 방식이지만, 라우터들이 일관된 라우팅 테이블 정보를 가지고 있지 않은 경우 루프가 발생할 수 있기 때문에 최근에는 잘 사용하지 않는 방식이다.
- 게이트웨이
    - 서로 다른 통신망, 프로톨을 사용하는 네트워크 간 통신을 가능하게 하는 관문 역할
- 클래스 기반 주소 할당 방식
  
    <img width="678" alt="image" src="https://github.com/user-attachments/assets/94fbac1c-445a-439f-89ff-a7e79e7c7915" />
    
    - 클래스 A, B, C - 일대일 통신으로 사용
    - 클래스 D - 브로드캐스트용 통신
    - 클래스 E - 예비용 주소
    - 구분 비트: IPv4 앞 쪽 몇 개의 비트로 이 주소가 A/B/C 클래스인지 구분하는 비트
        - IP 주소를 이진수로 표현했을 때, 0의 위치를 맨 앞에서부터 하나씩 뒤로 옮겨가며 표시함
        - 예) A 클래스 구분 비트 - ‘0’ / B 클래스 구분 비트  - ‘10’ / C 클래스 구분 비트 - ‘110’
    - 네트워크 주소
 
        <img width="646" alt="image" src="https://github.com/user-attachments/assets/9c5071a0-decd-42a9-8649-5f3e86095d75" />
        
        - 클래스 A 로 12.0.0.0 네트워크 부여된 상황이라면
        - 네트워크 구별 주소: 12.0.0.0
        - 호스트 주소: 12.0.0.1 ~ 12.255.255.254
        - 브로드캐스트 주소: 12.255.255.255
        - 단점: 클래스별 주소 개수가 정해져 있기 때문에 낭비가 심함 → IP 주소 고갈 문제와 이어짐
        ⇒ 이를 해결하기 위해 DHCP, IPv6, NAT 등장
- DHCP(Dynamic Host Configuration Protocol)
    - IP 주소 및 기타 통신 매개변수를 자동으로 할당하기 위한 네트워크 관리 프로토콜
    - 수동으로 IP 주소 할당할 필요 없이, 인터넷 접속할 때마다 자동으로 IP 주소가 할당됨
    - 동작 과정
        1. 장치가 네트워크 연결시 IP 요청
        2. DHCP 서버는 요청을 받아, 주소를 할당
        3. 주소 이용을 모니터링하다가 장치 연결이 해제되면 주소를 회수함
        4. 회수된 주소는 다시 다른 장치에 재할당할 수 있음
- NAT(Network Address Translation)
    - IPv4 주소 체계의 단점: 많은 주소들을 많이 감당하지 못 함 → NAT를 사용하여 공인 IP / 사설 IP로 나누어 주소를 처리함
    - 역할: 공인 IP ↔ 사설 IP 변환 시에 사용함
    - 장점: 공인 / 사설 IP가 분리되어 있기 때문에 보안성 증가
    - 단점: 실제 접속하는 호스트 숫자에 따라 접속 속도가 느려질 수 있음
    - 예) 와이파이 공우기
- IPv4
    - 8비트 단위로 점을 찍어 총 32비트로 표현
- IPv6
    - 16비트 단위로 점을 찍어 총 64비트로 표현
    - 등장 배경: IPv4 주소 고갈 문제를 해결하기 위해 등장

# 2.5 HTTP

### HTTP 1.0

- 한 연결당 하나의 요청 처리
- 연결마다 TCP 3-way Handshake 과정을 진행하기 때문에 RTT 증가

### HTTP 1.1

- 기본적으로 Keep alive 활성화되어 있음 → 한 번의 TCP 연결 후 여러 HTTP 요청을 처리할 수 있음
    - 여러 요청을 처리할 수 있다 ≠ 이전 요청의 상태를 기억한다
    - 연결은 이어져 있지만, HTTP 요청 자체는 여전히 독립적으로 처리함.
    - 요청이 평생 이어져 있는 것은 아님. 요청 횟수나 시간에 따라서 달라짐
- Pipelining 기능 추가
    - 1.0 버전까지는 요청에 대한 응답을 받고 나서야 새 요청을 보낼 수 있었음
    - 1.1부터는 하나의 연결 속에서 요청을 연속적으로 보낼 수 있음
    - 단점: Head of Line Blocking (특정 응답 지연)
        - 요청을 연속적으로 보낼 수 있지만, 요청과 응답의 순서과 동일해야 함
            
            → 특정 요청을 처리하는 데 많은 시간이 걸린다면 그 뒤에 있는 요청들은 응답을 받기까지 지연 시간이 길어짐
            
- 해결되지 못 한 문제
    1. HOLB 문제
    2. 무거운 헤더 구조: 많은 메타데이터가 헤더에 포함되어 있고, 압축되지 않았음

### HTTP 2.0

- 용어정리
    - frame: 2.0버전에서 새로 생긴 통신의 최소 단위. Header/Data가 들어 있음
    - Message: 1.1버전에서도 있었던 하나의 요청/응답을 가리킴
    - Stream: 요청&응답 하나의 메시지 쌍을 의미함
1. Multiplexed Streams
    - 1.1 버전에서는 하나의 연결 안에서 한 번에 한 개씩만 요청 가능
        - 여러 개를 한 번에 요청하고 싶다면? 연결을 여러 개 만들어야 함
        - 또는 순차적으로 주루룩 보낼 수 있지만, 앞 요청이 오래 걸리면 전체적으로 지연 발생함
    - 2.0 버전에서는 하나의 연결 내에서 여러 개의 Stream을 만들 수 있음
        - 응답은 Stream별로 순서없이 도착 → 선행 요청이 오래 걸려도 상관 없음
        - 여러 개를 동시에 요청하고 싶을 때 요청별로 Stream을 생성하여 병렬 처리 가능 → 속도 향상
        - 특정 스트림의 패킷이 손실되었다고 해도, 다른 스트림에는 영향 발생 X
2. Server Push
    - 클라이언트 요청에 대해 필요할 것 같은 리소스를 추가로 보내는 기능
    - 예) html 문서 요청 → 그 html 문서에 포함된 이미지, css, js 파일 등의 리소스를 추가로 보냄
    - 추가 리소스는 기존 스트림에서 push promise 전송 후 새로운 스트림에서 전송함 (클라이언트 요청 없이 응답만 보냄)
    - HTTP/2 Server Push의 흐름
        
        ## 📦 예를 들어보자: 브라우저가 `/index.html` 요청함
        
        ### 1️⃣ 클라이언트 → 서버
        
        ```
        
        Stream 1: GET /index.html
        ```
        
        ### 2️⃣ 서버 → 클라이언트
        
        1. **Stream 1에서 Push Promise 프레임을 보냄**
            - "나 곧 /style.css 줄게", "나 곧 /script.js 줄게"
            - 이건 **응답이 아니라 약속 프레임**이야
            - 클라이언트는 이걸 보고 "오케이, 알겠어"
        2. 그리고 나서…
        3. **Stream 2: /style.css 파일 자체 전송 시작**
        4. **Stream 3: /script.js 파일 자체 전송 시작**
        5. **Stream 1: /index.html에 대한 실제 HTML 응답 전송**
    - 장점: 트래픽 감소
3. 헤더 압축
    - 허프만 코딩 압축 알고리즘 사용
    - 허프만 코딩: 문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트 수를 사용하여 표현하고, 빈도가 낮은 정보는 비트 수를 많이 사용하여 표현하는 방식 → 전체 비트수를 줄일 수 있음

### HTTP 3.0

> HTTP 2.0이 등장하며 stream 별로 나누어 패킷을 전송할 수 있게 되어, HOLB 문제가 해소되었지만 여전히 TCP 기반 프로토콜이기 때문에 handshake 과정으로 인한 레이턴시가 발생했음. 이를 해결하기 위해 HTTP 3.0에서는 UDP 기반 QUIC 프로토콜 사용. QUIC는 TLS를 내장하여 보안 기능도 탑재하고 있으며 TCP와는 다르게 1 RTT 만으로 바로 데이터를 주고 받을 수 있음
> 
- 등장 배경: 2.0에서 multiplexed stream으로 인해 속도가 향상되었지만, 첫 연결까지 레이턴시 발생(TCP handshake 1 RTT + TLS handshake 2 RTT)
- HTTP 3.0 = QUIC + TLS 1.3
    - TCP 대신 UDP 기반의 QUIC 사용
    - TLS를 QUIC 프로토콜 안에 내장하여, 보안 + 전송 연결을 한 번에 처리
- 첫 연결: 1 RTT 필요
    - 클라이언트 → 서버: ClientHello(TLS의 SYN 느낌) + TLS 인증 정보
    - 서버 → 클라이언트: ServerHello(TLS의 SYN-ACK 느낌) + 세션 키 전달
    - 클라이언트: 서버 응답 확인 후 TLS 설정 완료
- 세션 재사용시 - 0 RTT로 냅다 바로 통신 가능
